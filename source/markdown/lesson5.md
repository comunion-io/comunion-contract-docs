# Solidity 介绍（二）

上一期我们介绍了合约的大致结构， 但是还有一些细节没有完善， 今天我们把剩下的学习完

## 合约的事件和枚举
Solidity 支持事件， 类似js, 但是与js 略有不同。 事件从合约中触发， 任何对它感兴趣的人， 都可以捕获并响应执行代码。合约中声明的事件在全局有效， 并且被合约中的函数锁执行， 使用event 关键字。事件的信息作为交易的一部分，记录在区块上。
```
event finishDisco(discoId)


function finishDisco(discoId) payable external (){
  finishDisco(discoId)
}
```

solidity 的枚举用于声明用户的自定义类型， 其中的常量值会显示的转换为整数， 每个常量对应一个整数值， 按照长度， 从0开始， 依次加1
```
enum gender {male female}
```

## 合约的函数
函数式solidity 的核心， 同时也是以太坊的重点。 以太坊中状态变量的更改， 都是通过函数类触发的， 当调用某个函数的时候， 会创建一个交易， 函数就是从状态读取到状态写入的唯一途径。 solidity 的特性中， 除了具名函数， 还有有且只能有一个的fallback 的未命名函数
```

```
函数使用function关键字类标识， 函数有大约8个限定符：
1. public 合约内部和外部都能调用
2. internal 只有当前合约或者继承的子合约才能调用
3. private 只能在当前合约中才能调用
4. external 只能从外部访问函数
5. constant 这种函数读取合约状态， 返回给调用者
6. view 与constant 一致
7. pure 被pure修饰的函数， 既不能读也不能写状态
8. payable 代表函数可以接收调用者的以太币

## 合约的数据类型
合约的数据类型，与js类似， 整体可以分为值类型和引用类型， 值类型会默认直接保存在内存中，在函数参数中， 需要加 memory 修饰， 值类型有以下几种
1. bool
2. uint
3. int
4. address
5. byte
6. enum




## 合约是如何存储数据的
合约中每个变量都有自己的数据位置， EVM 提供了四种存储变量的数据结构
1. 存储： 是可以被合约访问的全局变量， 会永久存储在以太坊上
2. 内存： 合约中的函数可以访问本地内存， 但是函数执行完成后会被立马销毁
3. 数据： 存储传入函数的参数
4. 堆栈： 是EVM 的工作内存集， 用户维护和加载变量

## 合约的数组
合约中的数组必须是相同类型的数据值， 数组是帮助讲这些值存储在一起。

```
uint[10] uintArray;
```

数组不要使用new 关键字去初始化， 推荐使用内联或者字面量的方式来初始化， 如果不规定数组长度， 数组就是动态数组
```
int[] discos = []
```

与其它语言一样， 字符串是一致特殊数组。

数组属性包括index, push, length

## 地址
当我们下载登录metamask后， 我们会获取一个钱包地址， 当我们部署合约到以太坊之后， 我们会获的一个合约地址。

地址是一个20个字节的数据类型， 它是为了存储以太坊中的账户地址而设计的一种特殊的数据类型， 地址都具有 balance 属性，用于查看当前地址下的以太坊数量。另外地址并不止是一串地址， 还能调用部署合约的函数。

正常情况下， 合约有两个函数用来交易以太币：
1. transfer: 向一个账户发送以太币的时候， 推荐使用transfer方法， 当转账失败， 会把金额退还给调用者
2. send： send 只会返回一个boolean 值，结果取决于调用函数是否执行成功










